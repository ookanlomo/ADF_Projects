"use strict";
/*!
 * @license
 * Copyright Â© 2005-2023 Hyland Software, Inc. and its affiliates. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlfrescoApiClient = exports.buildCollectionParam = void 0;
const tslib_1 = require("tslib");
const event_emitter_1 = tslib_1.__importDefault(require("event-emitter"));
const superagentHttpClient_1 = require("./superagentHttpClient");
const utils_1 = require("./utils");
function buildCollectionParam(param, collectionFormat) {
    if (!param) {
        return null;
    }
    switch (collectionFormat) {
        case 'csv':
            return param.map(utils_1.paramToString).join(',');
        case 'ssv':
            return param.map(utils_1.paramToString).join(' ');
        case 'tsv':
            return param.map(utils_1.paramToString).join('\t');
        case 'pipes':
            return param.map(utils_1.paramToString).join('|');
        case 'multi':
            return param.map(utils_1.paramToString);
        default:
            throw new Error('Unknown collection format: ' + collectionFormat);
    }
}
exports.buildCollectionParam = buildCollectionParam;
class AlfrescoApiClient {
    constructor(host, httpClient) {
        this.basePath = '';
        this.authentications = {
            basicAuth: {
                ticket: '',
            },
            type: 'basic',
        };
        this.defaultHeaders = {};
        this.timeout = undefined;
        this.contentTypes = {
            JSON: ['application/json'],
        };
        this.host = host;
        this.httpClient = httpClient || new superagentHttpClient_1.SuperagentHttpClient();
        (0, event_emitter_1.default)(this);
    }
    request(options) {
        return this.buildRequestCall(this.basePath, options, this.httpClient.request.bind(this.httpClient));
    }
    post(options) {
        const url = this.getCallApiUrl(options);
        return this.buildRequestCall(url, options, this.httpClient.post.bind(this.httpClient));
    }
    put(options) {
        const url = this.getCallApiUrl(options);
        return this.buildRequestCall(url, options, this.httpClient.put.bind(this.httpClient));
    }
    get(options) {
        const url = this.getCallApiUrl(options);
        return this.buildRequestCall(url, options, this.httpClient.get.bind(this.httpClient));
    }
    delete(options) {
        return this.buildRequestCall(this.basePath, options, this.httpClient.delete.bind(this.httpClient));
    }
    callApi(path, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, returnType, contextRoot, responseType, url) {
        const callApiUrl = url !== null && url !== void 0 ? url : this.getCallApiUrl({ contextRoot, path, pathParams });
        const options = {
            path,
            httpMethod,
            pathParams,
            queryParams,
            headerParams,
            formParams,
            bodyParam,
            contentTypes,
            accepts,
            returnType,
            contextRoot,
            responseType,
            url,
        };
        return this.buildRequestCall(callApiUrl, options, this.httpClient.request.bind(this.httpClient));
    }
    callCustomApi(path, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts, returnType, contextRoot, responseType) {
        const customApiUrl = AlfrescoApiClient.buildUrl(path, '', pathParams);
        const options = {
            path,
            httpMethod,
            pathParams,
            queryParams,
            headerParams,
            formParams,
            bodyParam,
            contentTypes,
            accepts,
            returnType,
            contextRoot,
            responseType,
        };
        return this.buildRequestCall(customApiUrl, options, this.httpClient.request.bind(this.httpClient));
    }
    isCsrfEnabled() {
        if (this.config) {
            return !this.config.disableCsrf;
        }
        else {
            return true;
        }
    }
    isBpmRequest() {
        return this.className === 'ProcessAuth' || this.className === 'ProcessClient';
    }
    basicAuth(username, password) {
        const str = username + ':' + password;
        let base64;
        if (typeof Buffer === 'function') {
            base64 = Buffer.from(str.toString(), 'binary').toString('base64');
        }
        else {
            base64 = btoa(str);
        }
        return 'Basic ' + base64;
    }
    isWithCredentials() {
        var _a;
        return !!((_a = this.config) === null || _a === void 0 ? void 0 : _a.withCredentials);
    }
    getAlfTicket(ticket) {
        const ticketParam = this.isWithCredentials() ? '&ticket=' : '&alf_ticket=';
        if (ticket) {
            return ticketParam + ticket;
        }
        else if (this.config.ticketEcm) {
            return ticketParam + this.config.ticketEcm;
        }
        return '';
    }
    static buildUrl(basePath, path, pathParams) {
        if (path && path !== '' && !path.match(/^\//)) {
            path = '/' + path;
        }
        const url = basePath + path;
        return AlfrescoApiClient.addParamsToUrl(url, pathParams);
    }
    static addParamsToUrl(path, pathParams) {
        return path.replace(/\{([\w-]+)\}/g, function (fullMatch, key) {
            let value;
            if (pathParams.hasOwnProperty(key)) {
                value = (0, utils_1.paramToString)(pathParams[key]);
            }
            else {
                value = fullMatch;
            }
            return encodeURIComponent(value);
        });
    }
    getCallApiUrl({ contextRoot, path, pathParams }) {
        const basePath = contextRoot ? `${this.host}/${contextRoot}` : this.basePath;
        return AlfrescoApiClient.buildUrl(basePath, path, pathParams);
    }
    buildRequestCall(url, options, httpCall) {
        const security = this.getSecurityOptions();
        const emitters = this.getEventEmitters();
        const httpRequestOptions = this.getRequestOptionsWithAcceptAndContentType(options);
        const promise = httpCall(url, httpRequestOptions, security, emitters);
        return this.addPromiseListeners(promise, emitters.eventEmitter);
    }
    getSecurityOptions() {
        return {
            isBpmRequest: this.isBpmRequest(),
            enableCsrf: this.isCsrfEnabled(),
            withCredentials: this.isWithCredentials(),
            authentications: this.authentications,
            defaultHeaders: this.defaultHeaders,
        };
    }
    getEventEmitters() {
        const apiClientEmitter = {
            on: this.on.bind(this),
            off: this.off.bind(this),
            once: this.once.bind(this),
            emit: this.emit.bind(this),
        };
        return {
            apiClientEmitter: apiClientEmitter,
            eventEmitter: (0, event_emitter_1.default)({}),
        };
    }
    getRequestOptionsWithAcceptAndContentType(options) {
        const contentType = AlfrescoApiClient.jsonPreferredMime(options.contentTypes);
        const accept = AlfrescoApiClient.jsonPreferredMime(options.accepts);
        return Object.assign(Object.assign({}, options), { contentType,
            accept });
    }
    static jsonPreferredMime(contentTypes) {
        if (!contentTypes || !contentTypes.length) {
            return 'application/json';
        }
        for (let i = 0; i < contentTypes.length; i++) {
            if (AlfrescoApiClient.isJsonMime(contentTypes[i])) {
                return contentTypes[i];
            }
        }
        return contentTypes[0];
    }
    static isJsonMime(contentType) {
        return Boolean(contentType !== null && contentType.match(/^application\/json(;.*)?$/i));
    }
    addPromiseListeners(promise, eventEmitter) {
        const alfrescoPromise = Object.assign(promise, {
            on: function () {
                eventEmitter.on.apply(eventEmitter, arguments);
                return this;
            },
            once: function () {
                eventEmitter.once.apply(eventEmitter, arguments);
                return this;
            },
            emit: function () {
                eventEmitter.emit.apply(eventEmitter, arguments);
                return this;
            },
            off: function () {
                eventEmitter.off.apply(eventEmitter, arguments);
                return this;
            },
        });
        return alfrescoPromise;
    }
}
exports.AlfrescoApiClient = AlfrescoApiClient;
//# sourceMappingURL=../../src/alfrescoApiClient.js.map