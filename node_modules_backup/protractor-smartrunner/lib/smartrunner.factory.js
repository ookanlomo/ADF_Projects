"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartRunnerFactory = void 0;
const logger_1 = require("protractor/built/logger");
const helpers_1 = require("./helpers");
const smartrunner_1 = require("./smartrunner");
const fs = require('fs-extra');
const LOGGER_ID = 'smartrunner';
const DEFAULT_OPTIONS = {
    outputDirectory: './.protractor-smartrunner',
    passedMessagePrefix: 'ðŸŸ¢ previously passed:',
    excludedMessagePrefix: 'ðŸŸ  excluded:',
    exclusionPath: null
};
class SmartRunnerFactory {
    constructor(providedOptions) {
        this.providedOptions = providedOptions;
        this.logger = new logger_1.Logger(LOGGER_ID);
    }
    getInstance() {
        return new smartrunner_1.SmartRunner(this.options, this.logger);
    }
    applyExclusionFilter() {
        const cliGrepped = helpers_1.isCliGrepped();
        if (!cliGrepped && this.options.exclusionPath) {
            const exclusionFileExists = fs.existsSync(this.options.exclusionPath);
            if (!exclusionFileExists) {
                this.logger.error(`ðŸ”´ Exclusion file doesn't exist: ${this.options.exclusionPath}`);
                process.exit(564);
            }
            const exclusions = helpers_1.getExclusions(this.options.exclusionPath);
            const grep = helpers_1.getExclusionGrep(this.options.exclusionPath);
            if (exclusions.length) {
                this.logger.info('ðŸš« Exclusion patterns: ', exclusions.join(', '));
                return { grep, invertGrep: true };
            }
        }
        else if (cliGrepped) {
            this.logger.warn(`ðŸŸ  Grep value has been passed as cli parameter, ignoring exclusion file`);
        }
        return {};
    }
    getResultsOutputPath() {
        return helpers_1.getResultsOutputPath(this.options.outputDirectory, this.options.repoHash);
    }
    get options() {
        return Object.assign(Object.assign({}, DEFAULT_OPTIONS), this.providedOptions);
    }
}
exports.SmartRunnerFactory = SmartRunnerFactory;
