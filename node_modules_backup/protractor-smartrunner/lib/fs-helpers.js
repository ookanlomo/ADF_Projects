"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateDiff = exports.loadResults = exports.backupResults = exports.BackupError = void 0;
const fs = require('fs-extra');
const path_1 = require("path");
class BackupError extends Error {
    constructor() {
        super(...arguments);
        this.type = 'backup-error';
    }
}
exports.BackupError = BackupError;
function backupResults(resultsPath) {
    if (!fs.existsSync(resultsPath)) {
        throw new BackupError(`Folder does not exist: ${resultsPath}`);
    }
    if (!fs.lstatSync(resultsPath).isDirectory()) {
        throw new BackupError(`Provided path is not a folder: ${resultsPath}`);
    }
    const results = loadResults(resultsPath);
    fs.outputJsonSync(getBackupFileName(resultsPath), results, { spaces: 4 });
    return results;
}
exports.backupResults = backupResults;
function loadResults(resultsPath) {
    if (!fs.existsSync(resultsPath)) {
        throw new Error(`Folder does not exist: ${resultsPath}`);
    }
    return fs.readdirSync(resultsPath)
        .filter((jsonFile) => /\.json$/.test(jsonFile))
        .map((jsonFile) => fs.readJsonSync(path_1.resolve(resultsPath, `./${jsonFile}`)))
        .reduce((accumulator, currentValue) => (Object.assign(Object.assign({}, accumulator), currentValue)), {});
}
exports.loadResults = loadResults;
function calculateDiff(resultsPath) {
    const backupFile = getBackupFileName(resultsPath);
    const latestResults = loadResults(resultsPath);
    if (!fs.existsSync(backupFile)) {
        console.log(`ℹ️  No backup file (${backupFile}) found, returning the latest result set without calculating difference.`);
        return latestResults;
    }
    const previousResults = fs.readJsonSync(backupFile);
    return calculateDiffForSuites(previousResults, latestResults);
}
exports.calculateDiff = calculateDiff;
function calculateDiffForSuites(previousRun, lastRun) {
    const suiteNames = Object.keys(previousRun);
    return suiteNames
        .map(suiteName => ({ suiteName, results: calculateDiffForTests(previousRun[suiteName], lastRun[suiteName]) }))
        .reduce((accumulator, current) => (Object.assign(Object.assign({}, accumulator), (Object.keys(current.results).length ? { [current.suiteName]: current.results } : {}))), {});
}
function calculateDiffForTests(previousRun, lastRun) {
    return Object.keys(previousRun)
        .filter(testName => { var _a; return !previousRun[testName].passed && (((_a = lastRun === null || lastRun === void 0 ? void 0 : lastRun[testName]) === null || _a === void 0 ? void 0 : _a.retries) - previousRun[testName].retries > 0); })
        .map(testName => ({
        testName,
        results: {
            retries: lastRun[testName].retries - previousRun[testName].retries,
            passed: lastRun[testName].passed,
            duration: lastRun[testName].duration
        }
    }))
        .reduce((accumulator, current) => (Object.assign(Object.assign({}, accumulator), { [current.testName]: current.results })), {});
}
function getBackupFileName(resultsPath) {
    return `${resultsPath}.bak.json`;
}
